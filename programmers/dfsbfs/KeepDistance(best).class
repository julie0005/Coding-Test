// 파티션이 있으면 더이상 이동하지 못하고 스탑, 파티션이 없으면 그대로 dfs 진행
import java.util.*;
class Solution {
    static int[] dx = {-1, 0, 1, 0};
    static int[] dy = {0, 1, 0, -1};
    static boolean[][] visit;

    static int[] answer;

    public void dfs(int num, int x, int y, int depth, String[] places) {
        if (depth > 2) return;
        if (depth > 0 && depth <= 2 && places[x].charAt(y) == 'P') {
            answer[num] = 0;
            return;
        }
        for (int i=0; i<4; i++) {
            int nx = x + dx[i];
            int ny = y + dy[i];
            if (nx >= 0 && nx < 5 && ny >= 0 && ny < 5 && places[nx].charAt(ny) != 'X') {
                if (visit[nx][ny]) continue;
                visit[nx][ny] = true;
                dfs(num, nx, ny, depth + 1, places);
                visit[nx][ny] = false;
            }
        }
    }

    public int[] solution(String[][] places) {
        answer = new int[places.length];
        for(int i=0; i<places.length; i++) {
            answer[i] = 1;
        }

        for (int i=0; i<places.length; i++) {
            visit = new boolean[5][5];
            for (int j=0; j<5; j++) {
                for(int k=0; k<5; k++) {
                    if (places[i][j].charAt(k) == 'P') {
                        visit[j][k] = true;
                        dfs(i, j, k, 0, places);
                        visit[j][k] = false;
                    }
                }
            }
        }

        return answer;
    }
}